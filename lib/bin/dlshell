#!/usr/local/bin/wish9.0

set dlshlib [file join /usr/local dlsh dlsh.zip]
set base [file join [zipfs root] dlsh]
zipfs mount $dlshlib $base
set auto_path [linsert $auto_path [set auto_path 0] $base/lib]

package require Tk
package require dlsh

# this should happen in dlsh package...
source $base/lib/dlsh/dgview.tcl

# Canvas graphics renderer for gbuf ASCII format
namespace eval gbuf {
    variable canvas
    variable scaleX 1.0
    variable scaleY 1.0
    variable windowLLX 0
    variable windowLLY 0
    variable windowURX 640
    variable windowURY 480
    variable currentColor "black"
    variable currentPosX 0
    variable currentPosY 0
    variable currentFont "Helvetica"
    variable currentFontSize 10
    variable textJustification 0
    variable textOrientation 0
    variable lineWidth 1
    variable lineStyle 0
    variable canvasWidth 640
    variable canvasHeight 480
    variable lastAsciiData ""
    variable resizeAfterId ""

    variable imageCache      ;# NEW: Array to cache decoded photo images
    array set imageCache {}
    
    # Color mapping
    variable colorMap
    array set colorMap {
        0  "#000000"  1  "#0000FF"  2  "#008000"  3  "#00FFFF"
        4  "#FF0000"  5  "#FF00FF"  6  "#A52A2A"  7  "#FFFFFF"
        8  "#808080"  9  "#ADD8E6"  10 "#00FF00"  11 "#E0FFFF"
        12 "#FF1493"  13 "#9370DB"  14 "#FFFF00"  15 "#FFFFFF"
	16 "#FFFFFF"
    }
    
    proc transformX {x} {
        variable scaleX
        return [expr {$x * $scaleX}]
    }
    
    proc transformY {y} {
        variable canvasHeight
        variable scaleY
        return [expr {$canvasHeight - ($y * $scaleY)}]
    }
    
    proc getColor {colorIndex} {
        variable colorMap
        
        if {$colorIndex > 31} {
            set shifted [expr {$colorIndex >> 5}]
            set r [expr {($shifted & 0xFF0000) >> 16}]
            set g [expr {($shifted & 0xFF00) >> 8}]
            set b [expr {$shifted & 0xFF}]
            return [format "#%02X%02X%02X" $r $g $b]
        }
        
        if {[info exists colorMap($colorIndex)]} {
            return $colorMap($colorIndex)
        }
        return "#000000"
    }
    
    proc onResize {w h} {
        variable resizeAfterId
        
        # Cancel any pending resize redraw
        if {$resizeAfterId ne ""} {
            after cancel $resizeAfterId
        }
        
        # Schedule redraw after resize settles (200ms delay)
        set resizeAfterId [after 200 [list gbuf::redrawAfterResize $w $h]]
    }
    
    proc redrawAfterResize {w h} {
        variable canvasWidth
        variable canvasHeight
        variable lastAsciiData
        variable resizeAfterId
        
        set resizeAfterId ""
        
        # Update canvas dimensions
        set canvasWidth $w
        set canvasHeight $h
        
        # Redraw if we have data
        if {$lastAsciiData ne ""} {
            processCommands $lastAsciiData
        }
    }
    
    # Shadow procs that match gbuf command names
    proc setwindow {llx lly urx ury} {
        variable windowLLX
        variable windowLLY
        variable windowURX
        variable windowURY
        variable scaleX
        variable scaleY
        variable canvasWidth
        variable canvasHeight
        
        set windowLLX $llx
        set windowLLY $lly
        set windowURX $urx
        set windowURY $ury
        
        if {$urx > $llx && $ury > $lly} {
            set scaleX [expr {double($canvasWidth) / ($urx - $llx)}]
            set scaleY [expr {double($canvasHeight) / ($ury - $lly)}]
        }
    }
    
    proc setcolor {colorIdx} {
        variable currentColor
        set currentColor [getColor $colorIdx]
    }
    
    proc setfont {fontname fontsize} {
        variable currentFont
        variable currentFontSize
        set currentFont $fontname
        set currentFontSize [expr {int($fontsize)}]
    }

    proc setlstyle {style} {
	variable lineStyle
	set lineStyle $style
    }

    proc getDashPattern {style} {
	set dashMap {
            0 {}              ;# Solid
            1 {}              ;# Solid
            2 {6 4}           ;# Dash
            3 {2 4}           ;# Dot
            4 {6 4 2 4}       ;# Dash-dot
            5 {6 4 2 4 2 4}   ;# Dash-dot-dot
            6 {12 4}          ;# Long dash
            7 {12 4 2 4}      ;# Long dash-dot
	}
	
	return [dict getdef $dashMap $style {}]
    }

    proc setlwidth {width} {
        variable lineWidth
        set lineWidth [expr {max(1, $width / 100.0)}]
    }
    
    proc setorientation {orient} {
        variable textOrientation
        set textOrientation $orient
    }
    
    proc setjust {just} {
        variable textJustification
        set textJustification $just
    }
    
    proc line {x1 y1 x2 y2} {
        variable canvas
        variable currentColor
        variable lineWidth
	variable lineStyle
        
        set sx1 [transformX $x1]
        set sy1 [transformY $y1]
        set sx2 [transformX $x2]
        set sy2 [transformY $y2]

	set dash [getDashPattern $lineStyle]
	
        $canvas create line $sx1 $sy1 $sx2 $sy2 -fill $currentColor -width $lineWidth -dash $dash
    }
    
    proc circle {cx cy radius {filled 0}} {
	variable canvas
	variable currentColor
	variable scaleX
	variable lineWidth
	variable lineStyle
	
	set sx [transformX $cx]
	set sy [transformY $cy]
	set sr [expr {$radius * $scaleX * 0.5}]
	set x1 [expr {$sx - $sr}]
	set y1 [expr {$sy - $sr}]
	set x2 [expr {$sx + $sr}]
	set y2 [expr {$sy + $sr}]
	
	set dash [getDashPattern $lineStyle]
	
	if {$filled != 0} {
        $canvas create oval $x1 $y1 $x2 $y2 \
		-fill $currentColor -outline $currentColor \
		-width $lineWidth -dash $dash
	   } else {
               $canvas create oval $x1 $y1 $x2 $y2 \
		       -outline $currentColor \
		       -width $lineWidth -dash $dash
	   }
    }
    
    proc fcircle {cx cy radius { filled 1 } } {
        variable canvas
        variable currentColor
        variable scaleX
        
        set sx [transformX $cx]
        set sy [transformY $cy]
        set sr [expr {$radius * $scaleX * 0.5}]
        set x1 [expr {$sx - $sr}]
        set y1 [expr {$sy - $sr}]
        set x2 [expr {$sx + $sr}]
        set y2 [expr {$sy + $sr}]
        $canvas create oval $x1 $y1 $x2 $y2 -fill $currentColor -outline $currentColor
    }
    
    proc filledrect {x1 y1 x2 y2} {
        variable canvas
        variable currentColor
        
        set sx1 [transformX $x1]
        set sy1 [transformY $y1]
        set sx2 [transformX $x2]
        set sy2 [transformY $y2]
        $canvas create rectangle $sx1 $sy1 $sx2 $sy2 -fill $currentColor -outline $currentColor
    }
    
    proc moveto {x y} {
        variable currentPosX
        variable currentPosY
        set currentPosX $x
        set currentPosY $y
    }
    
    proc lineto {x y} {
        variable canvas
        variable currentColor
        variable currentPosX
        variable currentPosY
        variable lineWidth
        variable lineStyle
	
        set sx1 [transformX $currentPosX]
        set sy1 [transformY $currentPosY]
        set sx2 [transformX $x]
        set sy2 [transformY $y]
	
	set dash [getDashPattern $lineStyle]
	$canvas create line $sx1 $sy1 $sx2 $sy2 \
		-fill $currentColor -width $lineWidth -dash $dash	

        set currentPosX $x
        set currentPosY $y
    }
    
    proc poly {args} {
        variable canvas
        variable currentColor
        variable lineWidth
	variable lineStyle
        
        set coords {}
        foreach {x y} $args {
            lappend coords [transformX $x] [transformY $y]
        }
	set dash [getDashPattern $lineStyle]
        $canvas create line {*}$coords -fill $currentColor -width $lineWidth -dash $dash
    }
    
    proc fpoly {args} {
        variable canvas
        variable currentColor
        
        set coords {}
        foreach {x y} $args {
            lappend coords [transformX $x] [transformY $y]
        }
        $canvas create polygon {*}$coords -fill $currentColor -outline $currentColor
    }
    
    proc drawtext {text} {
        variable canvas
        variable currentColor
        variable currentPosX
        variable currentPosY
        variable currentFont
        variable currentFontSize
        variable textJustification
        variable textOrientation
        
        set text [string trim $text "\""]
        set sx [transformX $currentPosX]
        set sy [transformY $currentPosY]
        
        set anchor "center"
        switch $textJustification {
            -1 { set anchor "w" }
             0 { set anchor "center" }
             1 { set anchor "e" }
        }
        
        # Convert orientation (0=0째, 1=90째, 2=180째, 3=270째) to degrees
        set angle [expr {$textOrientation * 90.0}]
        
        $canvas create text $sx $sy -text $text -fill $currentColor \
            -font [list $currentFont $currentFontSize] -anchor $anchor \
            -angle $angle
    }
    
    proc point {x y} {
        variable canvas
        variable currentColor
        
        set sx [transformX $x]
        set sy [transformY $y]
        $canvas create oval [expr {$sx-1}] [expr {$sy-1}] \
            [expr {$sx+1}] [expr {$sy+1}] -fill $currentColor -outline $currentColor
    }

    proc drawimage {x0 y0 x1 y1 image_id {w ""} {h ""} {d ""} {b64_data ""}} {
	variable canvas
	variable imageCache
	
	# Cache image data if provided inline
	if {$w ne "" && $h ne "" && $d ne "" && $b64_data ne ""} {
	    if {![info exists imageCache($image_id)]} {
		set img_dict [dict create \
				  id $image_id \
				  width $w \
				  height $h \
				  depth $d \
				  data $b64_data]
		cacheImageData $img_dict
	    }
	}
    
	# Render the image
	if {[info exists imageCache($image_id)]} {
	    set original_photo $imageCache($image_id)
	    
	    # Transform coordinates
	    set sx0 [transformX $x0]
	    set sy0 [transformY $y0]
	    set sx1 [transformX $x1]
	    set sy1 [transformY $y1]
	    
	    # After Y-flip, sy0 might be > sy1, so use min/max
	    set left [expr {min($sx0, $sx1)}]
	    set top [expr {min($sy0, $sy1)}]
	    set right [expr {max($sx0, $sx1)}]
	    set bottom [expr {max($sy0, $sy1)}]
	    
	    set desired_width [expr {int($right - $left)}]
	    set desired_height [expr {int($bottom - $top)}]
	    
	    # Get native image size
	    set native_width [image width $original_photo]
	    set native_height [image height $original_photo]
	    
	    # Calculate integer zoom factors
	    set zoom_x [expr {max(1, int(ceil(double($desired_width) / $native_width)))}]
	    set zoom_y [expr {max(1, int(ceil(double($desired_height) / $native_height)))}]
	    
	    # Create or reuse scaled photo
	    set scaled_name "${image_id}_${zoom_x}x${zoom_y}"
	    
	    if {![info exists imageCache($scaled_name)]} {
		set scaled_photo [image create photo]
		$scaled_photo copy $original_photo -zoom $zoom_x $zoom_y
		set imageCache($scaled_name) $scaled_photo
	    }
	    
	    # Draw at top-left corner
	    $canvas create image $left $top -image $imageCache($scaled_name) -anchor nw
	}
    }    

    
    proc cacheImageData {img_dict} {
	variable imageCache
	
	set id [dict get $img_dict id]
	
	# If already cached, don't recreate
	if {[info exists imageCache($id)]} {
	    return
	}
	
	set w [dict get $img_dict width]
	set h [dict get $img_dict height]
	set b64_data [dict get $img_dict data]
	
	# Decode base64 to char DynList
	dl_local dl [dl_clist]
	dl_fromString64 $b64_data $dl
	
	# Create Tk photo image
	set photo [image create photo -width $w -height $h]
	
	# Convert image data to color list (depth auto-inferred!)
	set img_data [dlg_imagedata2photo $dl $w $h]
	
	# Put all the data at once
	$photo put $img_data
	
	# Cache the photo image
	set imageCache($id) $photo
    }
    
    proc setclipregion {x1 y1 x2 y2} {
        # Clipping not implemented for canvas
    }
    
    proc clearwin {} {
	variable canvas
	variable imageCache
	
	$canvas delete all
	
	# Clean up cached images to free memory
	foreach id [array names imageCache] {
	    image delete $imageCache($id)
	    unset imageCache($id)
	}
    }
    
    proc gsave {} {
        # State save not implemented
    }
    
    proc grestore {} {
        # State restore not implemented
    }

    # Main rendering proc
    proc processCommands {asciiData} {
	variable canvas
	variable lastAsciiData
	
	# Save for potential redraw on resize
	set lastAsciiData $asciiData
	
	$canvas delete all
	
	foreach line [split $asciiData "\n"] {
	    set line [string trim $line]
	    if {$line eq "" || [string match "#*" $line]} continue
	    
	    namespace eval [namespace current] $line
	}
    }    
}


# Create canvas in main window
wm title . "Graphics Display"
set gbuf::canvas [canvas .c -width 640 -height 480 -bg white]
pack .c -fill both -expand 1

# Bind to canvas configure event (fires on resize)
bind $gbuf::canvas <Configure> {
    gbuf::onResize %w %h
}

# Wait for canvas to be drawn
update idletasks

# Define flushwin in global namespace
proc flushwin {} { 
    gbuf::processCommands [dumpwin string] 
}

rename clearwin _clearwin
proc clearwin {} {
    gbuf::clearwin
    _clearwin
}

# Now start tkcon if you want an interactive console
package require tkcon
set ::tkcon::OPT(exec) ""
tkcon show
